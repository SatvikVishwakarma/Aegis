# models.py

from __future__ import annotations

import datetime
from typing import List

from sqlalchemy import (
    DateTime,
    ForeignKey,
    Integer,
    JSON,
    String,
    Table,
    Column,
    func,
)
from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship


class Base(DeclarativeBase):
    """Base class for all SQLAlchemy ORM models."""
    pass


# Association Table for the Many-to-Many relationship between Node and Policy
# This table connects nodes to the policies assigned to them.
node_policy_association = Table(
    "node_policy_association",
    Base.metadata,
    Column("node_id", Integer, ForeignKey("nodes.id"), primary_key=True),
    Column("policy_id", Integer, ForeignKey("policies.id"), primary_key=True),
)


class Node(Base):
    """
    Represents a monitored node/agent in the system.
    """
    __tablename__ = "nodes"

    id: Mapped[int] = mapped_column(Integer, primary_key=True, index=True)
    hostname: Mapped[str] = mapped_column(String(255), unique=True, index=True, nullable=False)
    ip_address: Mapped[str] = mapped_column(String(45), unique=True, nullable=False)
    last_seen: Mapped[datetime.datetime] = mapped_column(
        DateTime,
        default=func.now(),
        onupdate=func.now(),
        doc="Timestamp of the last check-in from the node."
    )
    status: Mapped[str] = mapped_column(String(50), default="offline", nullable=False)

    # --- Relationships ---

    # One-to-Many: A Node can have many Events.
    # The 'events' attribute on a Node instance will be a list of Event objects.
    events: Mapped[List["Event"]] = relationship(
        "Event", back_populates="node", cascade="all, delete-orphan"
    )

    # Many-to-Many: A Node can have many Policies assigned to it.
    # The 'policies' attribute will be a list of Policy objects.
    policies: Mapped[List["Policy"]] = relationship(
        "Policy", secondary=node_policy_association, back_populates="assigned_nodes"
    )

    def __repr__(self) -> str:
        return f"<Node(id={self.id}, hostname='{self.hostname}', ip='{self.ip_address}')>"


class Policy(Base):
    """
    Represents a security policy that can be assigned to nodes.
    """
    __tablename__ = "policies"

    id: Mapped[int] = mapped_column(Integer, primary_key=True, index=True)
    name: Mapped[str] = mapped_column(String(255), unique=True, nullable=False)
    type: Mapped[str] = mapped_column(String(100), nullable=False, doc="e.g., firewall, ids, file_integrity")
    
    # Using JSON type for flexible rule storage.
    # For SQLite, SQLAlchemy handles this by storing it as TEXT.
    rules_json: Mapped[dict] = mapped_column(JSON, nullable=False)

    # --- Relationships ---

    # Many-to-Many: A Policy can be assigned to many Nodes.
    # The 'assigned_nodes' attribute will be a list of Node objects.
    assigned_nodes: Mapped[List["Node"]] = relationship(
        "Node", secondary=node_policy_association, back_populates="policies"
    )

    def __repr__(self) -> str:
        return f"<Policy(id={self.id}, name='{self.name}', type='{self.type}')>"


class Event(Base):
    """
    Represents a security event generated by a node.
    """
    __tablename__ = "events"

    id: Mapped[int] = mapped_column(Integer, primary_key=True, index=True)
    timestamp: Mapped[datetime.datetime] = mapped_column(
        DateTime, 
        server_default=func.now(), 
        nullable=False,
        index=True
    )
    event_type: Mapped[str] = mapped_column(String(100), nullable=False, index=True)
    severity: Mapped[str] = mapped_column(String(50), nullable=False, index=True, doc="e.g., low, medium, high, critical")
    
    # Flexible field to store event-specific data.
    details: Mapped[dict] = mapped_column(JSON, nullable=True)

    # --- Foreign Keys and Relationships ---

    # Foreign Key to link the Event to its source Node.
    node_id: Mapped[int] = mapped_column(Integer, ForeignKey("nodes.id"), nullable=False)

    # Many-to-One: Many Events belong to one Node.
    # The 'node' attribute provides direct access to the parent Node object.
    node: Mapped["Node"] = relationship("Node", back_populates="events")

    def __repr__(self) -> str:
        return f"<Event(id={self.id}, type='{self.event_type}', node_id={self.node_id})>"

# --- Example of how to initialize the database (for context) ---
# This part is typically executed from your main application entrypoint
# or a database initialization script.

# from sqlalchemy import create_engine
#
# SQLALCHEMY_DATABASE_URL = "sqlite:///./security_monitor.db"
#
# engine = create_engine(
#     SQLALCHEMY_DATABASE_URL, connect_args={"check_same_thread": False}
# )
#
# def create_db_and_tables():
#     # In a real app, this is often handled by a migration tool like Alembic
#     print("Creating database tables...")
#     Base.metadata.create_all(bind=engine)
#     print("Database tables created.")

# if __name__ == "__main__":
#     create_db_and_tables()